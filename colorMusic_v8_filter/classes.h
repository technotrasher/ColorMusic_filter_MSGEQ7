#ifndef __classes_h__
#define __classes_h__

/* Версия 1.0 от 24.02.2023 */

// упрошение функций
#define sFlag(flag, value) (flag) |= (value)
#define cFlag(flag, value) (flag) &= ~(value)
#define rFlag(flag, value) ((flag) & (value))

#define BIT(bitnum) (1 << (bitnum))
#define ON(color) sFlag(LEDPORT, BIT(color))
#define OFF(color) cFlag(LEDPORT, BIT(color))

#define offCh(channel) sFlag(CHPORT, channel)
#define onCh(channel) cFlag(CHPORT, channel)

#define N_BANDS 8             // количество сохраняемых аналоговых значений (каналов) = 7 полос + уровень 0,16В
#define ISACTIVE 0b00000001   // флаг невозможности использования отсчётов (заполняются новыми значениями)
#define ISREQ 0b00000010      // флаг запроса необходимости декодирования отсчётов (отсчёты заполнены, но не декодированы)
#define ISREADY 0b00000100    // флаг признака готовности отсчётов для использования (отсчёты заполнены и декодированы)
#define ISREADING 0b00001000  // флаг чтения буфера (защита от изменения в прерывании)

/* работа класса result:
  1. начальное состояние - _flags = 0
  2. прерывание АЦП полосы 0 устанавливает ISACTIVE, если нет ISREADING, одновременно очищаются ISREQ, ISREADY
     при ISREADING результаты сбрасываются и ожидается следующее срабатывание триггера  
  3. прерывание АЦП полосы 7 снимает ISACTIVE и устанавливает ISREQ
  4. если возникает прерывание АЦП полосы 0 - переход на 2
     если ilive возникает раньше прерывания АЦП полосы 0:
      - снимается ISREQ, устанавливается ISREADING
      - производится декодирование, снимается ISREADING, устанавливается ISREADY
  5. если возникает прерывание АЦП полосы 0 - переход на 2
     если в программе проверяется isReady раньше прерывания АЦП полосы 0:
      - снимается ISREADY, устанавливается ISREADING
      - читается буфер, сбрасывается ISREADING
  6. переходим на 1 */
/* класс сохранения данных о каналах
 */
class result {
public:
  result(byte channel)
    : _flags{ 0 } {             // инициирование - обнуление флагов, запоминание канала
    _channel = (1 << channel);  // сохраняем бит канала
    // pinMode(port, OUTPUT)
    sFlag(DDRD, _channel);  // установка пина управления каналом на output
    offChannel();           // выключение канала
  };
  inline volatile uint16_t *getBands() {
    return _bands;
  };  // возвращает адрес хранилища
  inline bool isActive() {
    return rFlag(_flags, ISACTIVE);
  };                    // возвращает признак изменения данных в отсчётах ISACTIVE
                        // rFlag проверяет бит в переменной
  inline bool isReq();  // возвращает признак необходимости пересчёта отсчётов ISREQ (со сбросом признака)
                        // запрещает изменения буфера до сброса ISREADING
  bool isReady();       // возвращает признак готовности новых отсчётов ISREADY (со сбросом признака)
                        // запрещает изменения буфера до сброса ISREADING
  inline bool isReading() {
    return rFlag(_flags, ISREADING);
  }                         // возвращает признак защиты буфера от изменений
                            // rFlag проверяет бит в переменной
  inline void setActive();  // устанавливает признак изменения данных в отсчётах
  inline void setReq();     // устанавливает признак необходимости пересчёта
  inline void clReading() {
    cFlag(_flags, ISREADING);
  };  // сбрасывает защиту буфера от изменений
      // cFlag обнуляет бит в переменной
  inline void onChannel() {
    onCh(_channel);
  };  // включает канал на измерение
      // digitalWrite(port, LOW)
  inline void offChannel() {
    offCh(_channel);
  };                // выключает канал
                    // digitalWrite(port, HIGH)
  uint8_t ilive();  // жизнь класса
private:
  byte _channel;                      // номер канала
  volatile uint16_t _bands[N_BANDS];  // хранилище отсчётов:  содержимое при ISACTIVE неопределено
                                      //                      содержимое при ISREQ - измеренные отсчёты
                                      //                      содержимое в остальные периоды (включая ISREADY) - декодированные отсчёты
                                      //                      ISREADING показывает, что с буфером производится работа (запрещено изменять в прерывании)
  volatile uint8_t _flags;            // флаги состояния канала
  void _decode();                     // обеспечение декодирования отсчётов
};

uint8_t result::ilive() {
  if (isReq()) {  // проверяем разрешение на декодирование
    _decode();    // производим декодирование
    return true;  // если производилось декодирование - возвратить признак
  }
  return false;  // если не производилось - сбросить признак
}

// ----- выполняется около 700мкс!!! требует оптимизации -----
void result::_decode() {
  uint16_t _B7 = _bands[N_BANDS - 1];    // constrain для значения уровня 0,16
  uint16_t *_band = (uint16_t *)_bands;  // временный указатель для исключения вычисления элемента массива
  for (byte i = 0; i < N_BANDS - 1; i++) {
    /* ----- пересчёт без логарифмирования -----*/
    *_band = ((*_band - _B7) << 5) / _B7;  // пересчёт в диапазон 0 - 1024
                                           /*--------------------------------------------*/
                                           /* ----- пересчёт с логарифмированием ------
    *_band = ((*_band - _B7)<<6) / _B7;                                   // пересчёт в диапазон 0 - 2048
    if (*_band & 0xFC00) *_band = 768 + ((*_band & 0x03FF)>>2);           // логарифмирование со вторым перегибом на половине диапазона
    else if (*_band & 0xFE00) *_band = 512 + ((*_band & 0x01FF)>>1);      // логарифмирование с первым перегибом на четверти диапазона
--------------------------------------------*/
    ++_band;                               // переход к следующей полосе
  }
  sFlag(_flags, ISREADY);    // разрешаем чтение из буфера: sFlag устанавливает бит в 1 переменной
  cFlag(_flags, ISREADING);  // разблокируем буфер: cFlag обнуляет бит в переменной
}

bool result::isReady() {         // вызывается из основной программы, требует защиты состояния от изменений в прерывании
  cli();                         // запрещаем прерывания, чтобы статус не мог быть изменён в прерывании
  if (rFlag(_flags, ISREADY)) {  // проверяем флаг
    sFlag(_flags, ISREADING);    // защищаем буфер от изменений в прерывании
    cFlag(_flags, ISREADY);      // сбрасываем флаг готовности данных
    sei();                       // разрешаем прерывания
    return true;                 // возвращаем разрешение на чтение данных
  }
  sei();         // разрешаем прерывания
  return false;  // возвращаем признак уже прочитанных данных
}

inline bool result::isReq() {  // вызывается из основной программы, требует защиты состояния от изменений в прерывании
  cli();                       // запрещаем прерывания, чтобы статус не мог быть изменён в прерывании
  if (rFlag(_flags, ISREQ)) {  // проверяем флаг: rFlag проверяет бит в переменной
    sFlag(_flags, ISREADING);  // защищаем буфер от изменений в прерывании (устанавливаем бит ISREADING)
    cFlag(_flags, ISREQ);      // сбрасываем флаг необходимости декодирования ISREQ
    sei();                     // разрешаем прерывания
    return true;               // возвращаем разрешение на декодирование
  }
  sei();         // разрешаем прерывания
  return false;  // возвращаем отсутствие необходимости в декодировании
};

inline void result::setActive() {  // вызывается из прерывания
  sFlag(_flags, ISACTIVE);         // запрещаем доступ к буферу (устанавливаем бит ISACTIVE)
  cFlag(_flags, ISREQ | ISREADY);  // сбрасываем разрешения на декодирование ISREQ и чтение ISREADY
}

inline void result::setReq() {  // вызывается из прерывания
  cFlag(_flags, ISACTIVE);      // разрешаем доступ к буферу (сбрасывает бит ISACTIVE)
  sFlag(_flags, ISREQ);         // разрешаем декодирование (устанавливаем бит ISREQ)
}

#endif